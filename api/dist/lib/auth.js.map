{
  "version": 3,
  "sources": ["../../src/lib/auth.ts"],
  "sourcesContent": ["import { APIGatewayEvent, Context } from 'aws-lambda';\nimport { User } from 'types/graphql';\n\nimport type { Decoded } from '@redwoodjs/api';\nimport { authDecoder as auth0Decoder } from '@redwoodjs/auth-auth0-api/dist/decoder';\nimport { dbAuthSession } from '@redwoodjs/auth-dbauth-api';\nimport { AuthenticationError, ForbiddenError } from '@redwoodjs/graphql-server';\n\nimport { AllowedRoles } from '../../../shared/types';\n\nimport { db } from './db';\n\n/**\n * The session object sent in as the first argument to getCurrentUser() will\n * have a single key `id` containing the unique ID of the logged in user\n * (whatever field you set as `authFields.id` in your auth function config).\n * You'll need to update the call to `db` below if you use a different model\n * name or unique field name, for example:\n *\n *   return await db.profile.findUnique({ where: { email: session.id } })\n *                   ───┬───                       ──┬──\n *      model accessor ─┘      unique id field name ─┘\n *\n * !! BEWARE !! Anything returned from this function will be available to the\n * client--it becomes the content of `currentUser` on the web side (as well as\n * `context.currentUser` on the api side). You should carefully add additional\n * fields to the `select` object below once you've decided they are safe to be\n * seen if someone were to open the Web Inspector in their browser.\n */\n\nenum AuthProviderTypes {\n  DbAuth = 'DbAuth',\n  Auth0 = 'Auth0',\n}\n\nexport const getCurrentUser = async (\n  session: Decoded,\n  params?: {\n    schema: string;\n    token: string;\n  }\n) => {\n  if (!session) {\n    throw new Error('Invalid session');\n  }\n\n  const selectedFields: Partial<Record<keyof User, boolean>> = {\n    id: true,\n    email: true,\n    roles: true,\n  };\n\n  // dbAuth ------------------------------------------------------------\n  if (typeof session.id === 'number') {\n    return db.user.findUnique({\n      where: { id: session.id },\n      select: selectedFields,\n    });\n  }\n\n  // Auth0---------------------------------------------------------------\n\n  //sub is Auth0 user id\n  const userIss = session.sub as string;\n\n  if (userIss) {\n    const result = await db.user.findFirst({\n      where: { iss: userIss },\n      select: selectedFields,\n    });\n\n    if (result) {\n      return result;\n    }\n  } else {\n    throw new Error('User iss not found');\n  }\n\n  const response = await fetch(`${session.iss}userinfo`, {\n    method: 'GET',\n    headers: new Headers({\n      Authorization: `Bearer ${params.token}`,\n    }),\n  });\n\n  const userData = await response.json();\n  const userEmail = userData.email;\n\n  if (userEmail) {\n    const result = await db.user.findUnique({\n      where: { email: userEmail },\n      select: selectedFields,\n    });\n\n    if (result) {\n      return result;\n    }\n  } else {\n    throw new Error('User email not found');\n  }\n\n  return db.user.create({\n    data: {\n      email: userEmail,\n      iss: userIss as string,\n      isVerified: true,\n      hashedPassword: '',\n      salt: '',\n    },\n  });\n};\n\n/**\n * The user is authenticated if there is a currentUser in the context\n *\n * @returns {boolean} - If the currentUser is authenticated\n */\nexport const isAuthenticated = (): boolean => {\n  return !!context.currentUser;\n};\n\nexport const authApi = async (event: APIGatewayEvent, context: Context) => {\n  const [, token] = event.headers.authorization.split(' ');\n\n  const authType = event.headers.authtype as AuthProviderTypes;\n  let session: Record<string, any>;\n\n  if (authType === AuthProviderTypes.Auth0) {\n    session = await auth0Decoder(token, 'auth0', { event, context });\n  } else {\n    session = dbAuthSession(event);\n  }\n\n  const user = await getCurrentUser(session, {\n    schema: 'Bearer',\n    token,\n  });\n\n  return {\n    isAuthenticated: !!user.id,\n    user,\n  };\n};\n\n/**\n * When checking role membership, roles can be a single value, a list, or none.\n * You can use Prisma enums too (if you're using them for roles), just import your enum type from `@prisma/client`\n */\n\n/**\n * Checks if the currentUser is authenticated (and assigned one of the given roles)\n *\n * @param roles: {@link AllowedRoles} - Checks if the currentUser is assigned one of these roles\n *\n * @returns {boolean} - Returns true if the currentUser is logged in and assigned one of the given roles,\n * or when no roles are provided to check against. Otherwise returns false.\n */\nexport const hasRole = (roles: AllowedRoles): boolean => {\n  if (!isAuthenticated()) {\n    return false;\n  }\n\n  const currentUserRoles = context.currentUser?.roles;\n\n  if (typeof roles === 'string') {\n    if (typeof currentUserRoles === 'string') {\n      return currentUserRoles === roles;\n    } else if (Array.isArray(currentUserRoles)) {\n      return currentUserRoles?.some((allowedRole) => roles === allowedRole);\n    }\n  }\n\n  if (Array.isArray(roles)) {\n    if (Array.isArray(currentUserRoles)) {\n      return currentUserRoles?.some((allowedRole) =>\n        roles.includes(allowedRole)\n      );\n    } else if (typeof currentUserRoles === 'string') {\n      return roles.some((allowedRole) => currentUserRoles === allowedRole);\n    }\n  }\n\n  // roles not found\n  return false;\n};\n\n/**\n * Use requireAuth in your services to check that a user is logged in,\n * whether or not they are assigned a role, and optionally raise an\n * error if they're not.\n *\n * @param roles: {@link AllowedRoles} - When checking role membership, these roles grant access.\n *\n * @returns - If the currentUser is authenticated (and assigned one of the given roles)\n *\n * @throws {@link AuthenticationError} - If the currentUser is not authenticated\n * @throws {@link ForbiddenError} If the currentUser is not allowed due to role permissions\n *\n * @see https://github.com/redwoodjs/redwood/tree/main/packages/auth for examples\n */\nexport const requireAuth = ({ roles }: { roles?: AllowedRoles } = {}) => {\n  if (!isAuthenticated()) {\n    throw new AuthenticationError(\"You don't have permission to do that.\");\n  }\n\n  if (roles && !hasRole(roles)) {\n    throw new ForbiddenError(\"You don't have access to do that.\");\n  }\n};\n"],
  "mappings": "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",
  "names": ["AuthProviderTypes", "getCurrentUser", "session", "params", "Error", "selectedFields", "id", "email", "roles", "db", "user", "findUnique", "where", "select", "userIss", "sub", "result", "findFirst", "iss", "response", "fetch", "method", "headers", "Headers", "Authorization", "token", "userData", "json", "userEmail", "create", "data", "isVerified", "hashedPassword", "salt", "isAuthenticated", "context", "currentUser", "authApi", "event", "authorization", "split", "authType", "authtype", "Auth0", "auth0Decoder", "dbAuthSession", "schema", "hasRole", "currentUserRoles", "_Array$isArray", "some", "allowedRole", "_includesInstanceProperty", "call", "_someInstanceProperty", "requireAuth", "AuthenticationError", "ForbiddenError"]
}
